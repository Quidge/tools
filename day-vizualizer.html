<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dayviz - Daily Time Block Planner</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, sans-serif;
      background: #f8f9fa;
    }

    #app {
      max-width: 800px;
      margin: 0 auto;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #toolbar {
      position: sticky;
      top: 0;
      z-index: 20;
      background: white;
      border-bottom: 1px solid #dadce0;
      padding: 8px 16px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .toolbar-btn {
      padding: 6px 12px;
      border: 1px solid #dadce0;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-family: system-ui, sans-serif;
      color: #202124;
      transition: background 0.1s;
    }

    .toolbar-btn:hover:not(:disabled) {
      background: #f1f3f4;
    }

    .toolbar-btn:disabled {
      color: #9aa0a6;
      cursor: not-allowed;
      opacity: 0.5;
    }

    #timeline-container {
      display: flex;
      overflow-y: auto;
      flex: 1;
      min-height: 0;
      background: white;
      border-left: 1px solid #dadce0;
      border-right: 1px solid #dadce0;
      position: relative;
    }

    #hour-labels {
      width: 60px;
      flex-shrink: 0;
      position: relative;
      height: 1920px;
      background: #fafafa;
      border-right: 1px solid #e0e0e0;
      font-size: 11px;
      color: #70757a;
    }

    .hour-label {
      position: absolute;
      transform: translateY(-50%);
      text-align: right;
      padding-right: 8px;
      width: 100%;
    }

    #timeline {
      position: relative;
      flex: 1;
      height: 1920px;
    }

    #grid-lines {
      position: absolute;
      inset: 0;
    }

    .grid-line {
      position: absolute;
      width: 100%;
      border-top: 1px solid #e0e0e0;
    }

    .grid-line-half {
      position: absolute;
      width: 100%;
      border-top: 1px dashed #e8e8e8;
    }

    .grid-line-quarter {
      position: absolute;
      width: 100%;
      border-top: 1px dotted #efefef;
    }

    .hour-label-half {
      position: absolute;
      transform: translateY(-50%);
      text-align: right;
      padding-right: 8px;
      width: 100%;
      font-size: 10px;
      color: #9aa0a6;
    }

    .hour-label-quarter {
      position: absolute;
      transform: translateY(-50%);
      text-align: right;
      padding-right: 8px;
      width: 100%;
      font-size: 9px;
      color: #bdc1c6;
    }

    #blocks-layer {
      position: absolute;
      inset: 0;
      left: 0;
      right: 8px;
    }

    .block {
      position: absolute;
      left: 4px;
      right: 4px;
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
      overflow: visible;
      transition: box-shadow 0.15s ease;
      background: #4285F4;
      border-left: 4px solid #1a73e8;
      color: white;
      font-size: 13px;
      line-height: 1.3;
    }

    .block.focused {
      background: #1a73e8;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      z-index: 10;
      cursor: grab;
    }

    .block-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
      overflow: hidden;
    }

    .block-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .block-duration {
      font-size: 11px;
      opacity: 0.85;
      white-space: nowrap;
      overflow: hidden;
    }

    .block-delete {
      position: absolute;
      top: 4px;
      right: 4px;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      padding: 2px 4px;
      border-radius: 3px;
      opacity: 0;
      transition: opacity 0.1s;
    }

    .block:hover .block-delete {
      opacity: 0.7;
    }

    .block-delete:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.2);
    }

    .resize-handle {
      position: absolute;
      left: 0;
      right: 0;
      height: 8px;
      z-index: 5;
      pointer-events: none;
    }

    .resize-handle-top {
      top: -4px;
    }

    .resize-handle-bottom {
      bottom: -4px;
    }

    .block.focused .resize-handle {
      pointer-events: auto;
      cursor: ns-resize;
    }

    .block.focused .resize-handle::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 24px;
      height: 2px;
      background: rgba(255, 255, 255, 0.5);
      box-shadow: 0 -3px 0 rgba(255, 255, 255, 0.5), 0 3px 0 rgba(255, 255, 255, 0.5);
    }

    .block.focused .resize-handle:hover::before {
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 -3px 0 rgba(255, 255, 255, 0.9), 0 3px 0 rgba(255, 255, 255, 0.9);
    }

    .time-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: inherit;
      pointer-events: none;
      z-index: 1000;
      display: none;
      white-space: nowrap;
    }

    body.dragging, body.moving {
      user-select: none;
      -webkit-user-select: none;
    }

    body.dragging {
      cursor: ns-resize !important;
    }

    body.dragging * {
      cursor: ns-resize !important;
    }

    body.moving {
      cursor: grabbing !important;
    }

    body.moving * {
      cursor: grabbing !important;
    }

    .block-ghost {
      position: absolute;
      left: 4px;
      right: 4px;
      border-radius: 6px;
      pointer-events: none;
      z-index: 15;
      background: transparent;
      border: 2px dashed #4ade80;
      transition: border-color 0.15s ease;
    }

    .block-ghost.invalid {
      border-color: #f87171;
    }

    .block.being-moved {
      opacity: 0.3;
    }

    .toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: #323232;
      color: white;
      padding: 10px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }

    .toast.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="toolbar">
      <button id="undo-btn" class="toolbar-btn" disabled title="Undo">&#x21A9; Undo</button>
      <button id="redo-btn" class="toolbar-btn" disabled title="Redo">Redo &#x21AA;</button>
      <span style="flex:1"></span>
      <button id="time-format-btn" class="toolbar-btn" title="Toggle 12/24 hour format">24hr</button>
      <button id="json-btn" class="toolbar-btn" title="Copy schedule as JSON">{ } JSON</button>
      <button id="share-btn" class="toolbar-btn" title="Copy shareable link">&#x1F517; Share</button>
    </div>
    <div id="timeline-container">
      <div id="hour-labels"></div>
      <div id="timeline">
        <div id="grid-lines"></div>
        <div id="blocks-layer"></div>
      </div>
    </div>
  </div>

  <script>
    // Constants
    const DAY_START = 0;
    const DAY_END = 1440;
    const SNAP = 5;
    const MIN_DURATION = 5;
    const DEFAULT_DURATION = 30;
    const HOUR_HEIGHT = 80;
    const MINUTE_HEIGHT = HOUR_HEIGHT / 60;

    // State
    const state = {
      blocks: [],
      focusedBlockId: null,
      drag: null,
      moveGhost: null,
      use12Hour: false,
      history: {
        past: [],   // array of blocks snapshots
        future: []  // array of blocks snapshots for redo
      }
    };

    // --- Demo / starter blocks ---

    function getDemoBlocks() {
      return [
        {
          id: generateId(),
          name: 'Double-click empty space to create a block',
          startTime: 540,
          endTime: 610
        },
        {
          id: generateId(),
          name: 'Click a block to focus it, then double-click to edit its name',
          startTime: 720,
          endTime: 800
        },
        {
          id: generateId(),
          name: 'Drag the handles of a focused block to resize it',
          startTime: 840,
          endTime: 900
        }
      ];
    }

    // --- Serialization & URL state ---

    // Unicode-safe base64 encoding/decoding (btoa/atob only handle Latin1)
    function toBase64(str) {
      const bytes = new TextEncoder().encode(str);
      let binary = '';
      for (const byte of bytes) binary += String.fromCharCode(byte);
      return btoa(binary);
    }

    function fromBase64(b64) {
      const binary = atob(b64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return new TextDecoder().decode(bytes);
    }

    function blocksToJSON(blocks) {
      return blocks.map(b => ({ name: b.name, start: b.startTime, end: b.endTime }));
    }

    function blocksFromJSON(arr) {
      return arr.map(item => ({
        id: generateId(),
        name: item.name || 'New Block',
        startTime: item.start,
        endTime: item.end
      }));
    }

    function encodeStateToURL() {
      if (state.blocks.length === 0) {
        // Keep empty 's' param so reloading stays empty (not demo blocks)
        const url = new URL(window.location);
        url.searchParams.set('s', '');
        window.history.replaceState(null, '', url);
        return;
      }
      const json = JSON.stringify(blocksToJSON(state.blocks));
      const encoded = toBase64(json);
      const url = new URL(window.location);
      url.searchParams.set('s', encoded);
      window.history.replaceState(null, '', url);
    }

    function decodeStateFromURL() {
      const params = new URLSearchParams(window.location.search);
      const encoded = params.get('s');
      if (!encoded) return null;
      try {
        const json = fromBase64(encoded);
        const arr = JSON.parse(json);
        if (!Array.isArray(arr)) return null;
        // Validate each entry
        for (const item of arr) {
          if (typeof item.start !== 'number' || typeof item.end !== 'number') return null;
          if (item.start < DAY_START || item.end > DAY_END || item.end - item.start < MIN_DURATION) return null;
        }
        return blocksFromJSON(arr);
      } catch (e) {
        return null;
      }
    }

    function getShareableURL() {
      const json = JSON.stringify(blocksToJSON(state.blocks));
      const encoded = toBase64(json);
      const url = new URL(window.location);
      url.searchParams.set('s', encoded);
      return url.toString();
    }

    function showToast(message) {
      let toast = document.getElementById('toast');
      if (!toast) {
        toast = document.createElement('div');
        toast.id = 'toast';
        toast.className = 'toast';
        document.body.appendChild(toast);
      }
      toast.textContent = message;
      toast.classList.add('visible');
      clearTimeout(toast._timeout);
      toast._timeout = setTimeout(() => toast.classList.remove('visible'), 2000);
    }

    // Helper functions
    function timeToY(minutes) {
      return minutes * MINUTE_HEIGHT;
    }

    function yToTime(y) {
      return snapToGrid(Math.max(DAY_START, Math.min(DAY_END, y / MINUTE_HEIGHT)));
    }

    function snapToGrid(minutes) {
      return Math.round(minutes / SNAP) * SNAP;
    }

    function formatTime(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      if (!state.use12Hour) {
        return `${hours}:${mins.toString().padStart(2, '0')}`;
      }
      const period = hours < 12 || hours === 24 ? 'AM' : 'PM';
      let h = hours % 12;
      if (h === 0) h = 12;
      return `${h}:${mins.toString().padStart(2, '0')} ${period}`;
    }

    function formatDuration(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;

      if (hours === 0) {
        return `${mins}m`;
      } else if (mins === 0) {
        return `${hours}h`;
      } else {
        return `${hours}h ${mins}m`;
      }
    }

    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
    }

    // Interaction helpers
    function getTimeFromMouseEvent(e) {
      const timeline = document.getElementById('timeline');
      const rect = timeline.getBoundingClientRect();
      const relativeY = e.clientY - rect.top;
      return yToTime(relativeY);
    }

    // History functions
    const HISTORY_LIMIT = 50;

    function saveHistory() {
      // Push current blocks snapshot to past
      state.history.past.push(structuredClone(state.blocks));
      // Trim to limit
      if (state.history.past.length > HISTORY_LIMIT) {
        state.history.past.shift();
      }
      // Clear future (new action invalidates redo)
      state.history.future = [];
      updateUndoRedoButtons();
    }

    function undo() {
      if (state.history.past.length === 0) return;
      // Save current to future
      state.history.future.push(structuredClone(state.blocks));
      // Restore previous
      state.blocks = state.history.past.pop();
      state.focusedBlockId = null; // Clear focus (block may not exist)
      updateUndoRedoButtons();
      renderBlocks();
      encodeStateToURL();
    }

    function redo() {
      if (state.history.future.length === 0) return;
      // Save current to past
      state.history.past.push(structuredClone(state.blocks));
      // Restore future
      state.blocks = state.history.future.pop();
      state.focusedBlockId = null;
      updateUndoRedoButtons();
      renderBlocks();
      encodeStateToURL();
    }

    function updateUndoRedoButtons() {
      document.getElementById('undo-btn').disabled = state.history.past.length === 0;
      document.getElementById('redo-btn').disabled = state.history.future.length === 0;
    }

    function findGapAt(time) {
      // Check if time is inside an existing block
      for (const block of state.blocks) {
        if (time >= block.startTime && time < block.endTime) {
          return null;
        }
      }

      // Find the gap containing this time
      let gapStart = DAY_START;
      let gapEnd = DAY_END;

      for (const block of state.blocks) {
        if (block.endTime <= time) {
          gapStart = Math.max(gapStart, block.endTime);
        }
        if (block.startTime > time) {
          gapEnd = Math.min(gapEnd, block.startTime);
          break;
        }
      }

      return { start: gapStart, end: gapEnd, size: gapEnd - gapStart };
    }

    function createBlockAt(time) {
      const gap = findGapAt(time);

      // Don't create if inside a block or gap too small
      if (!gap || gap.size < MIN_DURATION) {
        return;
      }

      // Calculate endTime, capped to available gap
      let endTime = Math.min(time + DEFAULT_DURATION, gap.end);

      // Safety check (should always be true)
      if (endTime - time < MIN_DURATION) {
        return;
      }

      // Save history before creation
      saveHistory();

      // Create new block
      const newBlock = {
        id: generateId(),
        name: 'New Block',
        startTime: time,
        endTime: endTime
      };

      state.blocks.push(newBlock);
      state.blocks.sort((a, b) => a.startTime - b.startTime);
      state.focusedBlockId = newBlock.id; // Auto-focus
      renderBlocks();
      encodeStateToURL();
    }

    function focusBlock(blockId) {
      if (state.focusedBlockId === blockId) return; // Already focused, skip re-render
      state.focusedBlockId = blockId;
      renderBlocks();
    }

    function unfocusBlock() {
      state.focusedBlockId = null;
      renderBlocks();
    }

    function activateInlineEdit(blockId) {
      const blockEl = document.querySelector(`[data-block-id="${blockId}"]`);
      if (!blockEl) return;

      const nameSpan = blockEl.querySelector('.block-name');
      if (!nameSpan) return;

      const block = state.blocks.find(b => b.id === blockId);
      if (!block) return;

      const originalName = block.name;

      // Save history before edit (so undo reverts to pre-edit name)
      saveHistory();

      // Create input element
      const input = document.createElement('input');
      input.type = 'text';
      input.value = originalName;
      input.style.cssText = `
        background: transparent;
        color: white;
        border: none;
        outline: none;
        width: 100%;
        font-size: 13px;
        font-weight: 500;
        font-family: system-ui, sans-serif;
        padding: 0;
        margin: 0;
        line-height: 1.3;
      `;

      // Track if we already committed/reverted to prevent double-fire
      let settled = false;

      const commit = () => {
        if (settled) return;
        settled = true;
        const newName = input.value.trim() || 'New Block';
        block.name = newName;
        renderBlocks();
        encodeStateToURL();
      };

      const revert = () => {
        if (settled) return;
        settled = true;
        // Remove the history entry we just saved (nothing changed)
        state.history.past.pop();
        updateUndoRedoButtons();
        renderBlocks();
      };

      input.addEventListener('blur', commit);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          input.removeEventListener('blur', commit);
          commit();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          input.removeEventListener('blur', commit);
          revert();
        }
        e.stopPropagation(); // Prevent delete shortcut from firing while editing
      });

      // Prevent click/mousedown from bubbling (would cause unfocus or other side effects)
      input.addEventListener('mousedown', (e) => e.stopPropagation());
      input.addEventListener('click', (e) => e.stopPropagation());

      // Replace span with input
      nameSpan.replaceWith(input);
      input.focus();
      input.select();
    }

    function deleteBlock(blockId) {
      // Save history before deletion
      saveHistory();

      state.blocks = state.blocks.filter(b => b.id !== blockId);
      if (state.focusedBlockId === blockId) {
        state.focusedBlockId = null;
      }
      renderBlocks();
      encodeStateToURL();
    }

    function pushBlocksRight(blockIndex, desiredEnd) {
      // Clamp to day boundary
      desiredEnd = Math.min(desiredEnd, DAY_END);

      const nextIndex = blockIndex + 1;

      // Base case: no next block, only day boundary limits us
      if (nextIndex >= state.blocks.length) {
        return desiredEnd;
      }

      const next = state.blocks[nextIndex];

      // No collision: free space available
      if (desiredEnd <= next.startTime) {
        return desiredEnd;
      }

      // COLLISION: push next block's start forward
      next.startTime = desiredEnd;

      // Check if next block can absorb the push by shrinking
      if (next.endTime - next.startTime >= MIN_DURATION) {
        return desiredEnd; // Absorbed — next block shrank but is still >= MIN_DURATION
      }

      // Next block is now too small — push its end forward recursively
      const nextDesiredEnd = next.startTime + MIN_DURATION;
      const nextActualEnd = pushBlocksRight(nextIndex, nextDesiredEnd);
      next.endTime = nextActualEnd;

      // If end couldn't expand fully (wall bounce), pull start back to maintain MIN_DURATION
      if (next.endTime - next.startTime < MIN_DURATION) {
        next.startTime = next.endTime - MIN_DURATION;
      }

      // Return what we can actually achieve: next block's start position
      return next.startTime;
    }

    function pushBlocksLeft(blockIndex, desiredStart) {
      // Clamp to day boundary
      desiredStart = Math.max(desiredStart, DAY_START);

      const prevIndex = blockIndex - 1;

      // Base case: no previous block, only day boundary limits us
      if (prevIndex < 0) {
        return desiredStart;
      }

      const prev = state.blocks[prevIndex];

      // No collision: free space available
      if (desiredStart >= prev.endTime) {
        return desiredStart;
      }

      // COLLISION: push prev block's end backward
      prev.endTime = desiredStart;

      // Check if prev block can absorb the push by shrinking
      if (prev.endTime - prev.startTime >= MIN_DURATION) {
        return desiredStart; // Absorbed
      }

      // Prev block is now too small — push its start backward recursively
      const prevDesiredStart = prev.endTime - MIN_DURATION;
      const prevActualStart = pushBlocksLeft(prevIndex, prevDesiredStart);
      prev.startTime = prevActualStart;

      // If start couldn't contract fully (wall bounce), push end forward to maintain MIN_DURATION
      if (prev.endTime - prev.startTime < MIN_DURATION) {
        prev.endTime = prev.startTime + MIN_DURATION;
      }

      // Return what we can actually achieve: prev block's end position
      return prev.endTime;
    }

    function simulatePushRight(blocks, blockIndex) {
      const block = blocks[blockIndex];
      const nextIndex = blockIndex + 1;
      if (nextIndex >= blocks.length) return;
      const next = blocks[nextIndex];
      if (block.endTime <= next.startTime) return; // No collision

      next.startTime = block.endTime;
      if (next.endTime - next.startTime >= MIN_DURATION) return; // Absorbed

      next.endTime = next.startTime + MIN_DURATION;
      simulatePushRight(blocks, nextIndex);

      // Wall bounce correction
      if (next.endTime > DAY_END) {
        next.endTime = DAY_END;
        if (next.endTime - next.startTime < MIN_DURATION) {
          next.startTime = next.endTime - MIN_DURATION;
        }
      }
    }

    function simulatePushLeft(blocks, blockIndex) {
      const block = blocks[blockIndex];
      const prevIndex = blockIndex - 1;
      if (prevIndex < 0) return;
      const prev = blocks[prevIndex];
      if (block.startTime >= prev.endTime) return; // No collision

      prev.endTime = block.startTime;
      if (prev.endTime - prev.startTime >= MIN_DURATION) return; // Absorbed

      prev.startTime = prev.endTime - MIN_DURATION;
      simulatePushLeft(blocks, prevIndex);

      // Wall bounce correction
      if (prev.startTime < DAY_START) {
        prev.startTime = DAY_START;
        if (prev.endTime - prev.startTime < MIN_DURATION) {
          prev.endTime = prev.startTime + MIN_DURATION;
        }
      }
    }

    function checkMoveViability(movingBlockId, dropStart, dropEnd) {
      // Clone blocks array (deep copy), excluding the moving block
      const tempBlocks = structuredClone(
        state.blocks.filter(b => b.id !== movingBlockId)
      );

      // Reject if the dropped block would fully cover any existing block
      for (const block of tempBlocks) {
        if (dropStart <= block.startTime && dropEnd >= block.endTime) {
          return { viable: false };
        }
      }

      // Create the moved block entry
      const movedBlock = { id: movingBlockId, startTime: dropStart, endTime: dropEnd };

      // Find insertion index
      let insertIdx = tempBlocks.findIndex(b => b.startTime >= dropStart);
      if (insertIdx === -1) insertIdx = tempBlocks.length;
      tempBlocks.splice(insertIdx, 0, movedBlock);

      // Simulate push right from the moved block
      simulatePushRight(tempBlocks, insertIdx);
      // Simulate push left from the moved block
      simulatePushLeft(tempBlocks, insertIdx);

      // Check all blocks have at least MIN_DURATION and are within day bounds
      for (const block of tempBlocks) {
        if (block.endTime - block.startTime < MIN_DURATION) return { viable: false };
        if (block.startTime < DAY_START || block.endTime > DAY_END) return { viable: false };
      }

      // Check no adjacent blocks overlap after simulation
      for (let i = 1; i < tempBlocks.length; i++) {
        if (tempBlocks[i].startTime < tempBlocks[i - 1].endTime) return { viable: false };
      }

      return { viable: true, resultBlocks: tempBlocks };
    }

    function applyResize(blockId, edge, targetTime) {
      const idx = state.blocks.findIndex(b => b.id === blockId);
      if (idx === -1) return;
      const block = state.blocks[idx];

      if (edge === 'bottom') {
        // Enforce minimum: target cannot be less than startTime + MIN_DURATION
        let newEnd = Math.max(targetTime, block.startTime + MIN_DURATION);
        // Push neighbors right, get achievable end position
        newEnd = pushBlocksRight(idx, newEnd);
        block.endTime = Math.max(newEnd, block.startTime + MIN_DURATION);
      } else {
        // top edge: enforce minimum: target cannot be more than endTime - MIN_DURATION
        let newStart = Math.min(targetTime, block.endTime - MIN_DURATION);
        // Push neighbors left, get achievable start position
        newStart = pushBlocksLeft(idx, newStart);
        block.startTime = Math.min(newStart, block.endTime - MIN_DURATION);
      }
    }

    function showTimeTooltip(time, e) {
      const tooltip = document.getElementById('time-tooltip');
      tooltip.textContent = formatTime(time);
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 15) + 'px';
      tooltip.style.top = (e.clientY - 10) + 'px';
    }

    function hideTimeTooltip() {
      const tooltip = document.getElementById('time-tooltip');
      tooltip.style.display = 'none';
    }

    // Auto-scroll during drag
    let autoScrollAnimationId = null;
    const AUTO_SCROLL_EDGE = 40; // pixels from container edge
    const AUTO_SCROLL_SPEED = 5; // pixels per frame

    function checkAutoScroll(e) {
      const container = document.getElementById('timeline-container');
      const rect = container.getBoundingClientRect();
      const relativeY = e.clientY - rect.top;

      if (relativeY < AUTO_SCROLL_EDGE) {
        startAutoScroll('up');
      } else if (relativeY > rect.height - AUTO_SCROLL_EDGE) {
        startAutoScroll('down');
      } else {
        stopAutoScroll();
      }
    }

    function startAutoScroll(direction) {
      if (autoScrollAnimationId) return; // Already scrolling

      const container = document.getElementById('timeline-container');

      function scroll() {
        if (direction === 'up') {
          container.scrollTop -= AUTO_SCROLL_SPEED;
        } else {
          container.scrollTop += AUTO_SCROLL_SPEED;
        }
        autoScrollAnimationId = requestAnimationFrame(scroll);
      }

      autoScrollAnimationId = requestAnimationFrame(scroll);
    }

    function stopAutoScroll() {
      if (autoScrollAnimationId) {
        cancelAnimationFrame(autoScrollAnimationId);
        autoScrollAnimationId = null;
      }
    }

    // Block movement functions
    function startBlockMove(blockId, mouseY) {
      const block = state.blocks.find(b => b.id === blockId);
      if (!block) return;

      const duration = block.endTime - block.startTime;
      const timeline = document.getElementById('timeline');
      const rect = timeline.getBoundingClientRect();
      // Calculate the offset from the top of the block to where the user grabbed
      const blockTopY = timeToY(block.startTime);
      const grabOffsetY = (mouseY - rect.top) - blockTopY;

      // Save history before move
      saveHistory();

      // Create ghost element
      const ghost = document.createElement('div');
      ghost.className = 'block-ghost';
      ghost.style.height = `${timeToY(duration)}px`;
      ghost.style.top = `${timeToY(block.startTime)}px`;
      document.getElementById('blocks-layer').appendChild(ghost);

      // Dim original block
      const blockEl = document.querySelector(`[data-block-id="${blockId}"]`);
      if (blockEl) blockEl.classList.add('being-moved');

      state.moveGhost = {
        blockId,
        duration,
        grabOffsetY,
        ghostElement: ghost,
        lastDropStart: block.startTime,
        originalStart: block.startTime,
        originalEnd: block.endTime,
        viable: true
      };

      document.body.classList.add('moving');
    }

    function updateGhostPosition(e) {
      if (!state.moveGhost) return;

      const timeline = document.getElementById('timeline');
      const rect = timeline.getBoundingClientRect();
      const rawY = (e.clientY - rect.top) - state.moveGhost.grabOffsetY;
      const dropStart = yToTime(rawY);

      // Clamp to day bounds
      const clampedStart = Math.max(DAY_START, Math.min(DAY_END - state.moveGhost.duration, dropStart));
      const dropEnd = clampedStart + state.moveGhost.duration;

      // Update ghost position
      state.moveGhost.ghostElement.style.top = `${timeToY(clampedStart)}px`;
      state.moveGhost.lastDropStart = clampedStart;

      // Viability check
      const result = checkMoveViability(state.moveGhost.blockId, clampedStart, dropEnd);
      state.moveGhost.viable = result.viable;
      state.moveGhost.resultBlocks = result.viable ? result.resultBlocks : null;

      if (result.viable) {
        state.moveGhost.ghostElement.classList.remove('invalid');
      } else {
        state.moveGhost.ghostElement.classList.add('invalid');
      }
    }

    function dropBlock() {
      if (!state.moveGhost) return;

      const { blockId, viable, resultBlocks, ghostElement, lastDropStart, originalStart } = state.moveGhost;

      // Remove ghost
      ghostElement.remove();

      // Check if dropped at original position (no-op)
      if (viable && lastDropStart === originalStart) {
        // Dropped at original position — no-op, pop the history entry
        state.history.past.pop();
        updateUndoRedoButtons();
      } else if (viable && resultBlocks) {
        // Apply the simulated result: update state.blocks with the result
        // Map IDs to new positions
        for (const resultBlock of resultBlocks) {
          const stateBlock = state.blocks.find(b => b.id === resultBlock.id);
          if (stateBlock) {
            stateBlock.startTime = resultBlock.startTime;
            stateBlock.endTime = resultBlock.endTime;
          }
        }
        // Re-sort blocks by startTime
        state.blocks.sort((a, b) => a.startTime - b.startTime);
      } else {
        // Move rejected — revert by popping the history snapshot we saved at startBlockMove
        state.history.past.pop();
        updateUndoRedoButtons();
      }

      state.moveGhost = null;
      document.body.classList.remove('moving');
      stopAutoScroll();
      renderBlocks();
      encodeStateToURL();
    }

    // Render blocks
    function renderBlocks() {
      const blocksLayer = document.getElementById('blocks-layer');
      const fragment = document.createDocumentFragment();

      state.blocks.forEach(block => {
        const blockEl = document.createElement('div');
        blockEl.className = 'block';
        if (block.id === state.focusedBlockId) {
          blockEl.classList.add('focused');
        }
        blockEl.dataset.blockId = block.id;

        const top = timeToY(block.startTime);
        const height = timeToY(block.endTime - block.startTime);
        blockEl.style.top = `${top}px`;
        blockEl.style.height = `${height}px`;

        const duration = block.endTime - block.startTime;

        const handleTop = document.createElement('div');
        handleTop.className = 'resize-handle resize-handle-top';

        const content = document.createElement('div');
        content.className = 'block-content';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'block-name';
        nameSpan.textContent = block.name;
        const durationSpan = document.createElement('span');
        durationSpan.className = 'block-duration';
        durationSpan.textContent = formatDuration(duration);
        content.appendChild(nameSpan);
        content.appendChild(durationSpan);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'block-delete';
        deleteBtn.title = 'Delete block';
        deleteBtn.textContent = '\u00d7';

        const handleBottom = document.createElement('div');
        handleBottom.className = 'resize-handle resize-handle-bottom';

        blockEl.appendChild(handleTop);
        blockEl.appendChild(content);
        blockEl.appendChild(deleteBtn);
        blockEl.appendChild(handleBottom);

        fragment.appendChild(blockEl);
      });

      blocksLayer.replaceChildren(fragment);
    }

    function formatHourLabel(hour) {
      if (!state.use12Hour) {
        return `${hour}:00`;
      }
      const period = hour < 12 || hour === 24 ? 'AM' : 'PM';
      let h = hour % 12;
      if (h === 0) h = 12;
      return `${h} ${period}`;
    }

    function renderHourLabels() {
      const hourLabels = document.getElementById('hour-labels');
      const gridLines = document.getElementById('grid-lines');
      hourLabels.innerHTML = '';
      gridLines.innerHTML = '';

      for (let hour = 0; hour <= 24; hour++) {
        // Hour label
        const label = document.createElement('div');
        label.className = 'hour-label';
        label.style.top = `${hour * HOUR_HEIGHT}px`;
        label.textContent = formatHourLabel(hour);
        hourLabels.appendChild(label);

        // Hour grid line
        const line = document.createElement('div');
        line.className = 'grid-line';
        line.style.top = `${hour * HOUR_HEIGHT}px`;
        gridLines.appendChild(line);

        // Sub-hour markers (skip for the last hour boundary)
        if (hour < 24) {
          // :15 marker
          const q1Label = document.createElement('div');
          q1Label.className = 'hour-label-quarter';
          q1Label.style.top = `${hour * HOUR_HEIGHT + HOUR_HEIGHT * 0.25}px`;
          q1Label.textContent = `:15`;
          hourLabels.appendChild(q1Label);

          const q1Line = document.createElement('div');
          q1Line.className = 'grid-line-quarter';
          q1Line.style.top = `${hour * HOUR_HEIGHT + HOUR_HEIGHT * 0.25}px`;
          gridLines.appendChild(q1Line);

          // :30 marker
          const halfLabel = document.createElement('div');
          halfLabel.className = 'hour-label-half';
          halfLabel.style.top = `${hour * HOUR_HEIGHT + HOUR_HEIGHT * 0.5}px`;
          halfLabel.textContent = `:30`;
          hourLabels.appendChild(halfLabel);

          const halfLine = document.createElement('div');
          halfLine.className = 'grid-line-half';
          halfLine.style.top = `${hour * HOUR_HEIGHT + HOUR_HEIGHT * 0.5}px`;
          gridLines.appendChild(halfLine);

          // :45 marker
          const q3Label = document.createElement('div');
          q3Label.className = 'hour-label-quarter';
          q3Label.style.top = `${hour * HOUR_HEIGHT + HOUR_HEIGHT * 0.75}px`;
          q3Label.textContent = `:45`;
          hourLabels.appendChild(q3Label);

          const q3Line = document.createElement('div');
          q3Line.className = 'grid-line-quarter';
          q3Line.style.top = `${hour * HOUR_HEIGHT + HOUR_HEIGHT * 0.75}px`;
          gridLines.appendChild(q3Line);
        }
      }
    }

    function toggleTimeFormat() {
      state.use12Hour = !state.use12Hour;
      document.getElementById('time-format-btn').textContent = state.use12Hour ? '12hr' : '24hr';
      renderHourLabels();
    }

    // Initialize timeline
    function initTimeline() {
      const timelineContainer = document.getElementById('timeline-container');
      const timeline = document.getElementById('timeline');

      // Generate hour labels, grid lines, and sub-hour markers
      renderHourLabels();

      // Load state from URL if present, otherwise show demo blocks
      const loadedBlocks = decodeStateFromURL();
      if (loadedBlocks && loadedBlocks.length > 0) {
        state.blocks = loadedBlocks;
        state.blocks.sort((a, b) => a.startTime - b.startTime);
      } else if (!new URLSearchParams(window.location.search).has('s')) {
        state.blocks = getDemoBlocks();
      }
      renderBlocks();

      // Scroll to ~5am area (300 minutes), or to first block if loaded from URL
      if (state.blocks.length > 0) {
        const firstBlockStart = state.blocks[0].startTime;
        // Scroll so the first block is near the top with some padding
        timelineContainer.scrollTop = Math.max(0, timeToY(firstBlockStart) - 40);
      } else {
        timelineContainer.scrollTop = timeToY(300);
      }

      // Wire toolbar buttons
      document.getElementById('undo-btn').addEventListener('click', undo);
      document.getElementById('redo-btn').addEventListener('click', redo);
      document.getElementById('time-format-btn').addEventListener('click', toggleTimeFormat);

      // Share button
      document.getElementById('share-btn').addEventListener('click', () => {
        if (state.blocks.length === 0) {
          showToast('Nothing to share — add some blocks first');
          return;
        }
        const url = getShareableURL();
        navigator.clipboard.writeText(url).then(() => {
          showToast('Shareable link copied to clipboard');
        }, () => {
          // Fallback: select a prompt
          showToast('Could not copy — check clipboard permissions');
        });
      });

      // JSON button
      document.getElementById('json-btn').addEventListener('click', () => {
        if (state.blocks.length === 0) {
          showToast('Nothing to export — add some blocks first');
          return;
        }
        const json = JSON.stringify(blocksToJSON(state.blocks), null, 2);
        navigator.clipboard.writeText(json).then(() => {
          showToast('JSON copied to clipboard');
        }, () => {
          showToast('Could not copy — check clipboard permissions');
        });
      });

      // Create tooltip element
      const tooltip = document.createElement('div');
      tooltip.className = 'time-tooltip';
      tooltip.id = 'time-tooltip';
      document.body.appendChild(tooltip);

      // Drag state tracking
      let justFinishedDrag = false;

      // Pending move state: defer block move until mouse actually moves,
      // so double-clicks aren't intercepted by the move system.
      let pendingMove = null;
      const MOVE_THRESHOLD = 3; // pixels of mouse movement before starting move

      // Event listeners
      timeline.addEventListener('mousedown', (e) => {
        const handle = e.target.closest('.resize-handle');
        if (handle) {
          const blockEl = handle.closest('.block');
          if (!blockEl || !blockEl.classList.contains('focused')) return;

          // Save history before resize starts
          saveHistory();

          const edge = handle.classList.contains('resize-handle-top') ? 'top' : 'bottom';
          state.drag = { blockId: blockEl.dataset.blockId, edge };

          document.body.classList.add('dragging');
          e.preventDefault(); // Prevent text selection
          e.stopPropagation(); // Prevent click handler from firing
          return;
        }

        // Check for move drag on focused block body — defer until mouse moves
        const blockEl = e.target.closest('.block');
        if (blockEl && blockEl.classList.contains('focused') && !e.target.closest('.resize-handle') && !e.target.closest('.block-delete')) {
          // Don't start move if clicking on an input (inline edit mode)
          if (e.target.tagName === 'INPUT') return;

          pendingMove = {
            blockId: blockEl.dataset.blockId,
            startX: e.clientX,
            startY: e.clientY
          };
          e.preventDefault();
          return;
        }
      });

      timeline.addEventListener('click', (e) => {
        if (justFinishedDrag) { justFinishedDrag = false; return; }
        if (e.target.closest('.resize-handle')) return;
        // Check for delete button FIRST
        const deleteBtn = e.target.closest('.block-delete');
        if (deleteBtn) {
          e.stopPropagation();
          const blockEl = deleteBtn.closest('.block');
          if (blockEl) {
            deleteBlock(blockEl.dataset.blockId);
          }
          return;
        }

        // Check for block click
        const blockEl = e.target.closest('.block');
        if (blockEl) {
          focusBlock(blockEl.dataset.blockId);
          return;
        }

        // Click on empty space — unfocus
        unfocusBlock();
      });

      timeline.addEventListener('dblclick', (e) => {
        // Don't activate edit when clicking on resize handles or delete button
        if (e.target.closest('.resize-handle') || e.target.closest('.block-delete')) return;

        // Check for double-click on a block (any part) for inline editing.
        // Use e.target.closest('.block') to handle clicks anywhere on the block,
        // including on detached elements (when renderBlocks() replaced DOM between clicks).
        const blockEl = e.target.closest('.block');
        if (blockEl) {
          const blockId = blockEl.dataset.blockId || state.focusedBlockId;
          if (blockId && blockId === state.focusedBlockId) {
            activateInlineEdit(state.focusedBlockId);
            return;
          }
          // Block is not focused — ignore (don't create new block)
          return;
        }

        // Double-click on empty space — but check if focusedBlockId was just set
        // by the first click of this double-click (happens when clicking unfocused block
        // body area not covered by .block element due to DOM replacement)
        if (state.focusedBlockId) {
          // Check if pointer position is over the current focused block in the DOM
          const focusedBlockEl = document.querySelector(`[data-block-id="${state.focusedBlockId}"]`);
          if (focusedBlockEl) {
            const rect = focusedBlockEl.getBoundingClientRect();
            if (e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom) {
              activateInlineEdit(state.focusedBlockId);
              return;
            }
          }
        }

        const time = getTimeFromMouseEvent(e);
        createBlockAt(time);
      });

      // Keyboard shortcut for delete
      document.addEventListener('keydown', (e) => {
        if (state.focusedBlockId && (e.key === 'Delete' || e.key === 'Backspace')) {
          // Don't trigger if user is in an input field
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
          }
          e.preventDefault();
          deleteBlock(state.focusedBlockId);
        }
      });

      // Document-level drag handlers (both resize and move)
      document.addEventListener('mousemove', (e) => {
        // Check if pending move should become an actual move
        if (pendingMove && !state.moveGhost) {
          const dx = e.clientX - pendingMove.startX;
          const dy = e.clientY - pendingMove.startY;
          if (Math.abs(dx) > MOVE_THRESHOLD || Math.abs(dy) > MOVE_THRESHOLD) {
            startBlockMove(pendingMove.blockId, pendingMove.startY);
            pendingMove = null;
          }
        }

        if (state.moveGhost) {
          updateGhostPosition(e);
          checkAutoScroll(e);
          return; // Don't process resize while moving
        }

        if (!state.drag) return;

        const targetTime = getTimeFromMouseEvent(e);
        applyResize(state.drag.blockId, state.drag.edge, targetTime);

        // Show tooltip with the edge time
        const block = state.blocks.find(b => b.id === state.drag.blockId);
        if (block) {
          const displayTime = state.drag.edge === 'bottom' ? block.endTime : block.startTime;
          showTimeTooltip(displayTime, e);
        }

        // Auto-scroll during resize drag
        checkAutoScroll(e);

        renderBlocks();
      });

      document.addEventListener('mouseup', (e) => {
        // Clear pending move if user released without exceeding threshold
        if (pendingMove) {
          pendingMove = null;
        }

        if (state.moveGhost) {
          dropBlock();
          justFinishedDrag = true;
          setTimeout(() => justFinishedDrag = false, 0);
          return;
        }

        if (!state.drag) return;

        justFinishedDrag = true;
        setTimeout(() => justFinishedDrag = false, 0);
        state.drag = null;
        document.body.classList.remove('dragging');
        hideTimeTooltip();
        stopAutoScroll();
        encodeStateToURL();
      });
    }

    // Initialize
    initTimeline();
  </script>
</body>
</html>
