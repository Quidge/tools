<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dayviz - Daily Time Block Planner</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Google Sans', Roboto, Arial, sans-serif;
      background: #f8f9fa;
    }

    #app {
      max-width: 800px;
      margin: 0 auto;
      height: 100vh;
    }

    #timeline-container {
      display: flex;
      overflow-y: auto;
      height: 100vh;
      background: white;
      border-left: 1px solid #dadce0;
      border-right: 1px solid #dadce0;
      position: relative;
    }

    #hour-labels {
      width: 60px;
      flex-shrink: 0;
      position: relative;
      height: 1920px;
      background: #fafafa;
      border-right: 1px solid #e0e0e0;
      font-size: 11px;
      color: #70757a;
    }

    .hour-label {
      position: absolute;
      transform: translateY(-50%);
      text-align: right;
      padding-right: 8px;
      width: 100%;
    }

    #timeline {
      position: relative;
      flex: 1;
      height: 1920px;
    }

    #grid-lines {
      position: absolute;
      inset: 0;
    }

    .grid-line {
      position: absolute;
      width: 100%;
      border-top: 1px solid #e0e0e0;
    }

    #blocks-layer {
      position: absolute;
      inset: 0;
      left: 0;
      right: 8px;
    }

    .block {
      position: absolute;
      left: 4px;
      right: 4px;
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
      overflow: visible;
      transition: box-shadow 0.15s ease;
      background: #4285F4;
      border-left: 4px solid #1a73e8;
      color: white;
      font-size: 13px;
      line-height: 1.3;
    }

    .block.focused {
      background: #1a73e8;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      z-index: 10;
    }

    .block-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
      overflow: hidden;
    }

    .block-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .block-duration {
      font-size: 11px;
      opacity: 0.85;
      white-space: nowrap;
      overflow: hidden;
    }

    .block-delete {
      position: absolute;
      top: 4px;
      right: 4px;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      padding: 2px 4px;
      border-radius: 3px;
      opacity: 0;
      transition: opacity 0.1s;
    }

    .block:hover .block-delete {
      opacity: 0.7;
    }

    .block-delete:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.2);
    }

    .resize-handle {
      position: absolute;
      left: 0;
      right: 0;
      height: 8px;
      z-index: 5;
      pointer-events: none;
    }

    .resize-handle-top {
      top: -4px;
    }

    .resize-handle-bottom {
      bottom: -4px;
    }

    .block.focused .resize-handle {
      pointer-events: auto;
      cursor: ns-resize;
    }

    .block.focused .resize-handle::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 24px;
      height: 2px;
      background: rgba(255, 255, 255, 0.5);
      box-shadow: 0 -3px 0 rgba(255, 255, 255, 0.5), 0 3px 0 rgba(255, 255, 255, 0.5);
    }

    .block.focused .resize-handle:hover::before {
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 -3px 0 rgba(255, 255, 255, 0.9), 0 3px 0 rgba(255, 255, 255, 0.9);
    }

    .time-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: inherit;
      pointer-events: none;
      z-index: 1000;
      display: none;
      white-space: nowrap;
    }

    body.dragging {
      user-select: none;
      cursor: ns-resize !important;
    }

    body.dragging * {
      cursor: ns-resize !important;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="timeline-container">
      <div id="hour-labels"></div>
      <div id="timeline">
        <div id="grid-lines"></div>
        <div id="blocks-layer"></div>
      </div>
    </div>
  </div>

  <script>
    // Constants
    const DAY_START = 0;
    const DAY_END = 1440;
    const SNAP = 5;
    const MIN_DURATION = 5;
    const DEFAULT_DURATION = 30;
    const HOUR_HEIGHT = 80;
    const MINUTE_HEIGHT = HOUR_HEIGHT / 60;

    // State
    const state = {
      blocks: [],
      focusedBlockId: null
    };

    // Helper functions
    function timeToY(minutes) {
      return minutes * MINUTE_HEIGHT;
    }

    function yToTime(y) {
      return snapToGrid(Math.max(DAY_START, Math.min(DAY_END, y / MINUTE_HEIGHT)));
    }

    function snapToGrid(minutes) {
      return Math.round(minutes / SNAP) * SNAP;
    }

    function formatTime(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${hours}:${mins.toString().padStart(2, '0')}`;
    }

    function formatDuration(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;

      if (hours === 0) {
        return `${mins}m`;
      } else if (mins === 0) {
        return `${hours}h`;
      } else {
        return `${hours}h ${mins}m`;
      }
    }

    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
    }

    // Interaction helpers
    function getTimeFromMouseEvent(e) {
      const timeline = document.getElementById('timeline');
      const rect = timeline.getBoundingClientRect();
      const relativeY = e.clientY - rect.top;
      return yToTime(relativeY);
    }

    function findGapAt(time) {
      // Check if time is inside an existing block
      for (const block of state.blocks) {
        if (time >= block.startTime && time < block.endTime) {
          return null;
        }
      }

      // Find the gap containing this time
      let gapStart = DAY_START;
      let gapEnd = DAY_END;

      for (const block of state.blocks) {
        if (block.endTime <= time) {
          gapStart = Math.max(gapStart, block.endTime);
        }
        if (block.startTime > time) {
          gapEnd = Math.min(gapEnd, block.startTime);
          break;
        }
      }

      return { start: gapStart, end: gapEnd, size: gapEnd - gapStart };
    }

    function createBlockAt(time) {
      const gap = findGapAt(time);

      // Don't create if inside a block or gap too small
      if (!gap || gap.size < MIN_DURATION) {
        return;
      }

      // Calculate endTime, capped to available gap
      let endTime = Math.min(time + DEFAULT_DURATION, gap.end);

      // Safety check (should always be true)
      if (endTime - time < MIN_DURATION) {
        return;
      }

      // Create new block
      const newBlock = {
        id: generateId(),
        name: 'New Block',
        startTime: time,
        endTime: endTime
      };

      state.blocks.push(newBlock);
      state.blocks.sort((a, b) => a.startTime - b.startTime);
      state.focusedBlockId = newBlock.id; // Auto-focus
      renderBlocks();
    }

    function focusBlock(blockId) {
      state.focusedBlockId = blockId;
      renderBlocks();
    }

    function unfocusBlock() {
      state.focusedBlockId = null;
      renderBlocks();
    }

    function deleteBlock(blockId) {
      state.blocks = state.blocks.filter(b => b.id !== blockId);
      if (state.focusedBlockId === blockId) {
        state.focusedBlockId = null;
      }
      renderBlocks();
    }

    // Render blocks
    function renderBlocks() {
      const blocksLayer = document.getElementById('blocks-layer');
      const fragment = document.createDocumentFragment();

      state.blocks.forEach(block => {
        const blockEl = document.createElement('div');
        blockEl.className = 'block';
        if (block.id === state.focusedBlockId) {
          blockEl.classList.add('focused');
        }
        blockEl.dataset.blockId = block.id;

        const top = timeToY(block.startTime);
        const height = timeToY(block.endTime - block.startTime);
        blockEl.style.top = `${top}px`;
        blockEl.style.height = `${height}px`;

        const duration = block.endTime - block.startTime;
        blockEl.innerHTML = `
          <div class="resize-handle resize-handle-top"></div>
          <div class="block-content">
            <span class="block-name">${block.name}</span>
            <span class="block-duration">${formatDuration(duration)}</span>
          </div>
          <button class="block-delete" title="Delete block">&times;</button>
          <div class="resize-handle resize-handle-bottom"></div>
        `;

        fragment.appendChild(blockEl);
      });

      blocksLayer.replaceChildren(fragment);
    }

    // Initialize timeline
    function initTimeline() {
      const hourLabels = document.getElementById('hour-labels');
      const gridLines = document.getElementById('grid-lines');
      const timelineContainer = document.getElementById('timeline-container');
      const timeline = document.getElementById('timeline');

      // Generate hour labels (0-24)
      for (let hour = 0; hour <= 24; hour++) {
        const label = document.createElement('div');
        label.className = 'hour-label';
        label.style.top = `${hour * HOUR_HEIGHT}px`;
        label.textContent = `${hour}:00`;
        hourLabels.appendChild(label);
      }

      // Generate grid lines (0-24)
      for (let hour = 0; hour <= 24; hour++) {
        const line = document.createElement('div');
        line.className = 'grid-line';
        line.style.top = `${hour * HOUR_HEIGHT}px`;
        gridLines.appendChild(line);
      }

      // Timeline starts empty (no hardcoded test blocks)
      renderBlocks();

      // Scroll to ~5am area (300 minutes)
      timelineContainer.scrollTop = timeToY(300);

      // Create tooltip element
      const tooltip = document.createElement('div');
      tooltip.className = 'time-tooltip';
      tooltip.id = 'time-tooltip';
      document.body.appendChild(tooltip);

      // Event listeners
      timeline.addEventListener('click', (e) => {
        // Check for delete button FIRST
        const deleteBtn = e.target.closest('.block-delete');
        if (deleteBtn) {
          e.stopPropagation();
          const blockEl = deleteBtn.closest('.block');
          if (blockEl) {
            deleteBlock(blockEl.dataset.blockId);
          }
          return;
        }

        // Check for block click
        const blockEl = e.target.closest('.block');
        if (blockEl) {
          focusBlock(blockEl.dataset.blockId);
          return;
        }

        // Click on empty space â€” unfocus
        unfocusBlock();
      });

      timeline.addEventListener('dblclick', (e) => {
        // Ignore double-click on existing blocks
        if (e.target.closest('.block')) {
          return;
        }

        const time = getTimeFromMouseEvent(e);
        createBlockAt(time);
      });

      // Keyboard shortcut for delete
      document.addEventListener('keydown', (e) => {
        if (state.focusedBlockId && (e.key === 'Delete' || e.key === 'Backspace')) {
          // Don't trigger if user is in an input field
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
          }
          e.preventDefault();
          deleteBlock(state.focusedBlockId);
        }
      });
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', initTimeline);
  </script>
</body>
</html>
