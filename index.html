<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dayviz - Daily Time Block Planner</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Google Sans', Roboto, Arial, sans-serif;
      background: #f8f9fa;
    }

    #app {
      max-width: 800px;
      margin: 0 auto;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #toolbar {
      position: sticky;
      top: 0;
      z-index: 20;
      background: white;
      border-bottom: 1px solid #dadce0;
      padding: 8px 16px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .toolbar-btn {
      padding: 6px 12px;
      border: 1px solid #dadce0;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Google Sans', Roboto, Arial, sans-serif;
      color: #202124;
      transition: background 0.1s;
    }

    .toolbar-btn:hover:not(:disabled) {
      background: #f1f3f4;
    }

    .toolbar-btn:disabled {
      color: #9aa0a6;
      cursor: not-allowed;
      opacity: 0.5;
    }

    #timeline-container {
      display: flex;
      overflow-y: auto;
      flex: 1;
      min-height: 0;
      background: white;
      border-left: 1px solid #dadce0;
      border-right: 1px solid #dadce0;
      position: relative;
    }

    #hour-labels {
      width: 60px;
      flex-shrink: 0;
      position: relative;
      height: 1920px;
      background: #fafafa;
      border-right: 1px solid #e0e0e0;
      font-size: 11px;
      color: #70757a;
    }

    .hour-label {
      position: absolute;
      transform: translateY(-50%);
      text-align: right;
      padding-right: 8px;
      width: 100%;
    }

    #timeline {
      position: relative;
      flex: 1;
      height: 1920px;
    }

    #grid-lines {
      position: absolute;
      inset: 0;
    }

    .grid-line {
      position: absolute;
      width: 100%;
      border-top: 1px solid #e0e0e0;
    }

    #blocks-layer {
      position: absolute;
      inset: 0;
      left: 0;
      right: 8px;
    }

    .block {
      position: absolute;
      left: 4px;
      right: 4px;
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
      overflow: visible;
      transition: box-shadow 0.15s ease;
      background: #4285F4;
      border-left: 4px solid #1a73e8;
      color: white;
      font-size: 13px;
      line-height: 1.3;
    }

    .block.focused {
      background: #1a73e8;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      z-index: 10;
      cursor: grab;
    }

    .block-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
      overflow: hidden;
    }

    .block-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .block-duration {
      font-size: 11px;
      opacity: 0.85;
      white-space: nowrap;
      overflow: hidden;
    }

    .block-delete {
      position: absolute;
      top: 4px;
      right: 4px;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      padding: 2px 4px;
      border-radius: 3px;
      opacity: 0;
      transition: opacity 0.1s;
    }

    .block:hover .block-delete {
      opacity: 0.7;
    }

    .block-delete:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.2);
    }

    .resize-handle {
      position: absolute;
      left: 0;
      right: 0;
      height: 8px;
      z-index: 5;
      pointer-events: none;
    }

    .resize-handle-top {
      top: -4px;
    }

    .resize-handle-bottom {
      bottom: -4px;
    }

    .block.focused .resize-handle {
      pointer-events: auto;
      cursor: ns-resize;
    }

    .block.focused .resize-handle::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 24px;
      height: 2px;
      background: rgba(255, 255, 255, 0.5);
      box-shadow: 0 -3px 0 rgba(255, 255, 255, 0.5), 0 3px 0 rgba(255, 255, 255, 0.5);
    }

    .block.focused .resize-handle:hover::before {
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 -3px 0 rgba(255, 255, 255, 0.9), 0 3px 0 rgba(255, 255, 255, 0.9);
    }

    .time-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: inherit;
      pointer-events: none;
      z-index: 1000;
      display: none;
      white-space: nowrap;
    }

    body.dragging, body.moving {
      user-select: none;
      -webkit-user-select: none;
    }

    body.dragging {
      cursor: ns-resize !important;
    }

    body.dragging * {
      cursor: ns-resize !important;
    }

    body.moving {
      cursor: grabbing !important;
    }

    body.moving * {
      cursor: grabbing !important;
    }

    .block-ghost {
      position: absolute;
      left: 4px;
      right: 4px;
      border-radius: 6px;
      pointer-events: none;
      z-index: 15;
      background: transparent;
      border: 2px dashed #4ade80;
      transition: border-color 0.15s ease;
    }

    .block-ghost.invalid {
      border-color: #f87171;
    }

    .block.being-moved {
      opacity: 0.3;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="toolbar">
      <button id="undo-btn" class="toolbar-btn" disabled title="Undo">&#x21A9; Undo</button>
      <button id="redo-btn" class="toolbar-btn" disabled title="Redo">Redo &#x21AA;</button>
    </div>
    <div id="timeline-container">
      <div id="hour-labels"></div>
      <div id="timeline">
        <div id="grid-lines"></div>
        <div id="blocks-layer"></div>
      </div>
    </div>
  </div>

  <script>
    // Constants
    const DAY_START = 0;
    const DAY_END = 1440;
    const SNAP = 5;
    const MIN_DURATION = 5;
    const DEFAULT_DURATION = 30;
    const HOUR_HEIGHT = 80;
    const MINUTE_HEIGHT = HOUR_HEIGHT / 60;

    // State
    const state = {
      blocks: [],
      focusedBlockId: null,
      drag: null,
      moveGhost: null,
      history: {
        past: [],   // array of blocks snapshots
        future: []  // array of blocks snapshots for redo
      }
    };

    // Helper functions
    function timeToY(minutes) {
      return minutes * MINUTE_HEIGHT;
    }

    function yToTime(y) {
      return snapToGrid(Math.max(DAY_START, Math.min(DAY_END, y / MINUTE_HEIGHT)));
    }

    function snapToGrid(minutes) {
      return Math.round(minutes / SNAP) * SNAP;
    }

    function formatTime(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${hours}:${mins.toString().padStart(2, '0')}`;
    }

    function formatDuration(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;

      if (hours === 0) {
        return `${mins}m`;
      } else if (mins === 0) {
        return `${hours}h`;
      } else {
        return `${hours}h ${mins}m`;
      }
    }

    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
    }

    // Interaction helpers
    function getTimeFromMouseEvent(e) {
      const timeline = document.getElementById('timeline');
      const rect = timeline.getBoundingClientRect();
      const relativeY = e.clientY - rect.top;
      return yToTime(relativeY);
    }

    // History functions
    const HISTORY_LIMIT = 50;

    function saveHistory() {
      // Push current blocks snapshot to past
      state.history.past.push(JSON.parse(JSON.stringify(state.blocks)));
      // Trim to limit
      if (state.history.past.length > HISTORY_LIMIT) {
        state.history.past.shift();
      }
      // Clear future (new action invalidates redo)
      state.history.future = [];
      updateUndoRedoButtons();
    }

    function undo() {
      if (state.history.past.length === 0) return;
      // Save current to future
      state.history.future.push(JSON.parse(JSON.stringify(state.blocks)));
      // Restore previous
      state.blocks = state.history.past.pop();
      state.focusedBlockId = null; // Clear focus (block may not exist)
      updateUndoRedoButtons();
      renderBlocks();
    }

    function redo() {
      if (state.history.future.length === 0) return;
      // Save current to past
      state.history.past.push(JSON.parse(JSON.stringify(state.blocks)));
      // Restore future
      state.blocks = state.history.future.pop();
      state.focusedBlockId = null;
      updateUndoRedoButtons();
      renderBlocks();
    }

    function updateUndoRedoButtons() {
      document.getElementById('undo-btn').disabled = state.history.past.length === 0;
      document.getElementById('redo-btn').disabled = state.history.future.length === 0;
    }

    function findGapAt(time) {
      // Check if time is inside an existing block
      for (const block of state.blocks) {
        if (time >= block.startTime && time < block.endTime) {
          return null;
        }
      }

      // Find the gap containing this time
      let gapStart = DAY_START;
      let gapEnd = DAY_END;

      for (const block of state.blocks) {
        if (block.endTime <= time) {
          gapStart = Math.max(gapStart, block.endTime);
        }
        if (block.startTime > time) {
          gapEnd = Math.min(gapEnd, block.startTime);
          break;
        }
      }

      return { start: gapStart, end: gapEnd, size: gapEnd - gapStart };
    }

    function createBlockAt(time) {
      const gap = findGapAt(time);

      // Don't create if inside a block or gap too small
      if (!gap || gap.size < MIN_DURATION) {
        return;
      }

      // Calculate endTime, capped to available gap
      let endTime = Math.min(time + DEFAULT_DURATION, gap.end);

      // Safety check (should always be true)
      if (endTime - time < MIN_DURATION) {
        return;
      }

      // Save history before creation
      saveHistory();

      // Create new block
      const newBlock = {
        id: generateId(),
        name: 'New Block',
        startTime: time,
        endTime: endTime
      };

      state.blocks.push(newBlock);
      state.blocks.sort((a, b) => a.startTime - b.startTime);
      state.focusedBlockId = newBlock.id; // Auto-focus
      renderBlocks();
    }

    function focusBlock(blockId) {
      state.focusedBlockId = blockId;
      renderBlocks();
    }

    function unfocusBlock() {
      state.focusedBlockId = null;
      renderBlocks();
    }

    function activateInlineEdit(blockId) {
      const blockEl = document.querySelector(`[data-block-id="${blockId}"]`);
      if (!blockEl) return;

      const nameSpan = blockEl.querySelector('.block-name');
      if (!nameSpan) return;

      const block = state.blocks.find(b => b.id === blockId);
      if (!block) return;

      const originalName = block.name;

      // Save history before edit (so undo reverts to pre-edit name)
      saveHistory();

      // Create input element
      const input = document.createElement('input');
      input.type = 'text';
      input.value = originalName;
      input.style.cssText = `
        background: transparent;
        color: white;
        border: none;
        outline: none;
        width: 100%;
        font-size: 13px;
        font-weight: 500;
        font-family: 'Google Sans', Roboto, Arial, sans-serif;
        padding: 0;
        margin: 0;
        line-height: 1.3;
      `;

      // Track if we already committed/reverted to prevent double-fire
      let settled = false;

      const commit = () => {
        if (settled) return;
        settled = true;
        const newName = input.value.trim() || 'New Block';
        block.name = newName;
        renderBlocks();
      };

      const revert = () => {
        if (settled) return;
        settled = true;
        // Remove the history entry we just saved (nothing changed)
        state.history.past.pop();
        updateUndoRedoButtons();
        renderBlocks();
      };

      input.addEventListener('blur', commit);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          input.removeEventListener('blur', commit);
          commit();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          input.removeEventListener('blur', commit);
          revert();
        }
        e.stopPropagation(); // Prevent delete shortcut from firing while editing
      });

      // Prevent click/mousedown from bubbling (would cause unfocus or other side effects)
      input.addEventListener('mousedown', (e) => e.stopPropagation());
      input.addEventListener('click', (e) => e.stopPropagation());

      // Replace span with input
      nameSpan.replaceWith(input);
      input.focus();
      input.select();
    }

    function deleteBlock(blockId) {
      // Save history before deletion
      saveHistory();

      state.blocks = state.blocks.filter(b => b.id !== blockId);
      if (state.focusedBlockId === blockId) {
        state.focusedBlockId = null;
      }
      renderBlocks();
    }

    function pushBlocksRight(blockIndex, desiredEnd) {
      // Clamp to day boundary
      desiredEnd = Math.min(desiredEnd, DAY_END);

      const nextIndex = blockIndex + 1;

      // Base case: no next block, only day boundary limits us
      if (nextIndex >= state.blocks.length) {
        return desiredEnd;
      }

      const next = state.blocks[nextIndex];

      // No collision: free space available
      if (desiredEnd <= next.startTime) {
        return desiredEnd;
      }

      // COLLISION: push next block's start forward
      next.startTime = desiredEnd;

      // Check if next block can absorb the push by shrinking
      if (next.endTime - next.startTime >= MIN_DURATION) {
        return desiredEnd; // Absorbed — next block shrank but is still >= MIN_DURATION
      }

      // Next block is now too small — push its end forward recursively
      const nextDesiredEnd = next.startTime + MIN_DURATION;
      const nextActualEnd = pushBlocksRight(nextIndex, nextDesiredEnd);
      next.endTime = nextActualEnd;

      // If end couldn't expand fully (wall bounce), pull start back to maintain MIN_DURATION
      if (next.endTime - next.startTime < MIN_DURATION) {
        next.startTime = next.endTime - MIN_DURATION;
      }

      // Return what we can actually achieve: next block's start position
      return next.startTime;
    }

    function pushBlocksLeft(blockIndex, desiredStart) {
      // Clamp to day boundary
      desiredStart = Math.max(desiredStart, DAY_START);

      const prevIndex = blockIndex - 1;

      // Base case: no previous block, only day boundary limits us
      if (prevIndex < 0) {
        return desiredStart;
      }

      const prev = state.blocks[prevIndex];

      // No collision: free space available
      if (desiredStart >= prev.endTime) {
        return desiredStart;
      }

      // COLLISION: push prev block's end backward
      prev.endTime = desiredStart;

      // Check if prev block can absorb the push by shrinking
      if (prev.endTime - prev.startTime >= MIN_DURATION) {
        return desiredStart; // Absorbed
      }

      // Prev block is now too small — push its start backward recursively
      const prevDesiredStart = prev.endTime - MIN_DURATION;
      const prevActualStart = pushBlocksLeft(prevIndex, prevDesiredStart);
      prev.startTime = prevActualStart;

      // If start couldn't contract fully (wall bounce), push end forward to maintain MIN_DURATION
      if (prev.endTime - prev.startTime < MIN_DURATION) {
        prev.endTime = prev.startTime + MIN_DURATION;
      }

      // Return what we can actually achieve: prev block's end position
      return prev.endTime;
    }

    function simulatePushRight(blocks, blockIndex) {
      const block = blocks[blockIndex];
      const nextIndex = blockIndex + 1;
      if (nextIndex >= blocks.length) return;
      const next = blocks[nextIndex];
      if (block.endTime <= next.startTime) return; // No collision

      next.startTime = block.endTime;
      if (next.endTime - next.startTime >= MIN_DURATION) return; // Absorbed

      next.endTime = next.startTime + MIN_DURATION;
      simulatePushRight(blocks, nextIndex);

      // Wall bounce correction
      if (next.endTime > DAY_END) {
        next.endTime = DAY_END;
        if (next.endTime - next.startTime < MIN_DURATION) {
          next.startTime = next.endTime - MIN_DURATION;
        }
      }
    }

    function simulatePushLeft(blocks, blockIndex) {
      const block = blocks[blockIndex];
      const prevIndex = blockIndex - 1;
      if (prevIndex < 0) return;
      const prev = blocks[prevIndex];
      if (block.startTime >= prev.endTime) return; // No collision

      prev.endTime = block.startTime;
      if (prev.endTime - prev.startTime >= MIN_DURATION) return; // Absorbed

      prev.startTime = prev.endTime - MIN_DURATION;
      simulatePushLeft(blocks, prevIndex);

      // Wall bounce correction
      if (prev.startTime < DAY_START) {
        prev.startTime = DAY_START;
        if (prev.endTime - prev.startTime < MIN_DURATION) {
          prev.endTime = prev.startTime + MIN_DURATION;
        }
      }
    }

    function checkMoveViability(movingBlockId, dropStart, dropEnd) {
      // Clone blocks array (deep copy), excluding the moving block
      const tempBlocks = JSON.parse(JSON.stringify(
        state.blocks.filter(b => b.id !== movingBlockId)
      ));

      // Create the moved block entry
      const movedBlock = { id: movingBlockId, startTime: dropStart, endTime: dropEnd };

      // Find insertion index
      let insertIdx = tempBlocks.findIndex(b => b.startTime >= dropStart);
      if (insertIdx === -1) insertIdx = tempBlocks.length;
      tempBlocks.splice(insertIdx, 0, movedBlock);

      // Simulate push right from the moved block
      simulatePushRight(tempBlocks, insertIdx);
      // Simulate push left from the moved block
      simulatePushLeft(tempBlocks, insertIdx);

      // Check all blocks have at least MIN_DURATION and are within day bounds
      for (const block of tempBlocks) {
        if (block.endTime - block.startTime < MIN_DURATION) return { viable: false };
        if (block.startTime < DAY_START || block.endTime > DAY_END) return { viable: false };
      }

      return { viable: true, resultBlocks: tempBlocks };
    }

    function applyResize(blockId, edge, targetTime) {
      const idx = state.blocks.findIndex(b => b.id === blockId);
      if (idx === -1) return;
      const block = state.blocks[idx];

      if (edge === 'bottom') {
        // Enforce minimum: target cannot be less than startTime + MIN_DURATION
        let newEnd = Math.max(targetTime, block.startTime + MIN_DURATION);
        // Push neighbors right, get achievable end position
        newEnd = pushBlocksRight(idx, newEnd);
        block.endTime = Math.max(newEnd, block.startTime + MIN_DURATION);
      } else {
        // top edge: enforce minimum: target cannot be more than endTime - MIN_DURATION
        let newStart = Math.min(targetTime, block.endTime - MIN_DURATION);
        // Push neighbors left, get achievable start position
        newStart = pushBlocksLeft(idx, newStart);
        block.startTime = Math.min(newStart, block.endTime - MIN_DURATION);
      }
    }

    function showTimeTooltip(time, e) {
      const tooltip = document.getElementById('time-tooltip');
      tooltip.textContent = formatTime(time);
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 15) + 'px';
      tooltip.style.top = (e.clientY - 10) + 'px';
    }

    function hideTimeTooltip() {
      const tooltip = document.getElementById('time-tooltip');
      tooltip.style.display = 'none';
    }

    // Auto-scroll during drag
    let autoScrollAnimationId = null;
    const AUTO_SCROLL_EDGE = 40; // pixels from container edge
    const AUTO_SCROLL_SPEED = 5; // pixels per frame

    function checkAutoScroll(e) {
      const container = document.getElementById('timeline-container');
      const rect = container.getBoundingClientRect();
      const relativeY = e.clientY - rect.top;

      if (relativeY < AUTO_SCROLL_EDGE) {
        startAutoScroll('up');
      } else if (relativeY > rect.height - AUTO_SCROLL_EDGE) {
        startAutoScroll('down');
      } else {
        stopAutoScroll();
      }
    }

    function startAutoScroll(direction) {
      if (autoScrollAnimationId) return; // Already scrolling

      const container = document.getElementById('timeline-container');

      function scroll() {
        if (direction === 'up') {
          container.scrollTop -= AUTO_SCROLL_SPEED;
        } else {
          container.scrollTop += AUTO_SCROLL_SPEED;
        }
        autoScrollAnimationId = requestAnimationFrame(scroll);
      }

      autoScrollAnimationId = requestAnimationFrame(scroll);
    }

    function stopAutoScroll() {
      if (autoScrollAnimationId) {
        cancelAnimationFrame(autoScrollAnimationId);
        autoScrollAnimationId = null;
      }
    }

    // Block movement functions
    function startBlockMove(blockId, mouseY) {
      const block = state.blocks.find(b => b.id === blockId);
      if (!block) return;

      const duration = block.endTime - block.startTime;
      const timeline = document.getElementById('timeline');
      const rect = timeline.getBoundingClientRect();
      // Calculate the offset from the top of the block to where the user grabbed
      const blockTopY = timeToY(block.startTime);
      const grabOffsetY = (mouseY - rect.top) - blockTopY;

      // Save history before move
      saveHistory();

      // Create ghost element
      const ghost = document.createElement('div');
      ghost.className = 'block-ghost';
      ghost.style.height = `${timeToY(duration)}px`;
      ghost.style.top = `${timeToY(block.startTime)}px`;
      document.getElementById('blocks-layer').appendChild(ghost);

      // Dim original block
      const blockEl = document.querySelector(`[data-block-id="${blockId}"]`);
      if (blockEl) blockEl.classList.add('being-moved');

      state.moveGhost = {
        blockId,
        duration,
        grabOffsetY,
        ghostElement: ghost,
        lastDropStart: block.startTime,
        originalStart: block.startTime,
        originalEnd: block.endTime,
        viable: true
      };

      document.body.classList.add('moving');
    }

    function updateGhostPosition(e) {
      if (!state.moveGhost) return;

      const timeline = document.getElementById('timeline');
      const rect = timeline.getBoundingClientRect();
      const rawY = (e.clientY - rect.top) - state.moveGhost.grabOffsetY;
      const dropStart = yToTime(rawY);

      // Clamp to day bounds
      const clampedStart = Math.max(DAY_START, Math.min(DAY_END - state.moveGhost.duration, dropStart));
      const dropEnd = clampedStart + state.moveGhost.duration;

      // Update ghost position
      state.moveGhost.ghostElement.style.top = `${timeToY(clampedStart)}px`;
      state.moveGhost.lastDropStart = clampedStart;

      // Viability check
      const result = checkMoveViability(state.moveGhost.blockId, clampedStart, dropEnd);
      state.moveGhost.viable = result.viable;
      state.moveGhost.resultBlocks = result.viable ? result.resultBlocks : null;

      if (result.viable) {
        state.moveGhost.ghostElement.classList.remove('invalid');
      } else {
        state.moveGhost.ghostElement.classList.add('invalid');
      }
    }

    function dropBlock() {
      if (!state.moveGhost) return;

      const { blockId, viable, resultBlocks, ghostElement, lastDropStart, originalStart } = state.moveGhost;

      // Remove ghost
      ghostElement.remove();

      // Check if dropped at original position (no-op)
      if (viable && lastDropStart === originalStart) {
        // Dropped at original position — no-op, pop the history entry
        state.history.past.pop();
        updateUndoRedoButtons();
      } else if (viable && resultBlocks) {
        // Apply the simulated result: update state.blocks with the result
        // Map IDs to new positions
        for (const resultBlock of resultBlocks) {
          const stateBlock = state.blocks.find(b => b.id === resultBlock.id);
          if (stateBlock) {
            stateBlock.startTime = resultBlock.startTime;
            stateBlock.endTime = resultBlock.endTime;
          }
        }
        // Re-sort blocks by startTime
        state.blocks.sort((a, b) => a.startTime - b.startTime);
      } else {
        // Move rejected — revert by popping the history snapshot we saved at startBlockMove
        state.history.past.pop();
        updateUndoRedoButtons();
      }

      state.moveGhost = null;
      document.body.classList.remove('moving');
      stopAutoScroll();
      renderBlocks();
    }

    // Render blocks
    function renderBlocks() {
      const blocksLayer = document.getElementById('blocks-layer');
      const fragment = document.createDocumentFragment();

      state.blocks.forEach(block => {
        const blockEl = document.createElement('div');
        blockEl.className = 'block';
        if (block.id === state.focusedBlockId) {
          blockEl.classList.add('focused');
        }
        blockEl.dataset.blockId = block.id;

        const top = timeToY(block.startTime);
        const height = timeToY(block.endTime - block.startTime);
        blockEl.style.top = `${top}px`;
        blockEl.style.height = `${height}px`;

        const duration = block.endTime - block.startTime;
        blockEl.innerHTML = `
          <div class="resize-handle resize-handle-top"></div>
          <div class="block-content">
            <span class="block-name">${block.name}</span>
            <span class="block-duration">${formatDuration(duration)}</span>
          </div>
          <button class="block-delete" title="Delete block">&times;</button>
          <div class="resize-handle resize-handle-bottom"></div>
        `;

        fragment.appendChild(blockEl);
      });

      blocksLayer.replaceChildren(fragment);
    }

    // Initialize timeline
    function initTimeline() {
      const hourLabels = document.getElementById('hour-labels');
      const gridLines = document.getElementById('grid-lines');
      const timelineContainer = document.getElementById('timeline-container');
      const timeline = document.getElementById('timeline');

      // Generate hour labels (0-24)
      for (let hour = 0; hour <= 24; hour++) {
        const label = document.createElement('div');
        label.className = 'hour-label';
        label.style.top = `${hour * HOUR_HEIGHT}px`;
        label.textContent = `${hour}:00`;
        hourLabels.appendChild(label);
      }

      // Generate grid lines (0-24)
      for (let hour = 0; hour <= 24; hour++) {
        const line = document.createElement('div');
        line.className = 'grid-line';
        line.style.top = `${hour * HOUR_HEIGHT}px`;
        gridLines.appendChild(line);
      }

      // Timeline starts empty (no hardcoded test blocks)
      renderBlocks();

      // Scroll to ~5am area (300 minutes)
      timelineContainer.scrollTop = timeToY(300);

      // Wire toolbar buttons
      document.getElementById('undo-btn').addEventListener('click', undo);
      document.getElementById('redo-btn').addEventListener('click', redo);

      // Create tooltip element
      const tooltip = document.createElement('div');
      tooltip.className = 'time-tooltip';
      tooltip.id = 'time-tooltip';
      document.body.appendChild(tooltip);

      // Drag state tracking
      let justFinishedDrag = false;

      // Event listeners
      timeline.addEventListener('mousedown', (e) => {
        const handle = e.target.closest('.resize-handle');
        if (handle) {
          const blockEl = handle.closest('.block');
          if (!blockEl || !blockEl.classList.contains('focused')) return;

          // Save history before resize starts
          saveHistory();

          const edge = handle.classList.contains('resize-handle-top') ? 'top' : 'bottom';
          state.drag = { blockId: blockEl.dataset.blockId, edge };

          document.body.classList.add('dragging');
          e.preventDefault(); // Prevent text selection
          e.stopPropagation(); // Prevent click handler from firing
          return;
        }

        // Check for move drag on focused block body
        const blockEl = e.target.closest('.block');
        if (blockEl && blockEl.classList.contains('focused') && !e.target.closest('.resize-handle') && !e.target.closest('.block-delete')) {
          // Don't start move if clicking on an input (inline edit mode)
          if (e.target.tagName === 'INPUT') return;

          startBlockMove(blockEl.dataset.blockId, e.clientY);
          e.preventDefault();
          return;
        }
      });

      timeline.addEventListener('click', (e) => {
        if (justFinishedDrag) { justFinishedDrag = false; return; }
        if (e.target.closest('.resize-handle')) return;
        // Check for delete button FIRST
        const deleteBtn = e.target.closest('.block-delete');
        if (deleteBtn) {
          e.stopPropagation();
          const blockEl = deleteBtn.closest('.block');
          if (blockEl) {
            deleteBlock(blockEl.dataset.blockId);
          }
          return;
        }

        // Check for block click
        const blockEl = e.target.closest('.block');
        if (blockEl) {
          focusBlock(blockEl.dataset.blockId);
          return;
        }

        // Click on empty space — unfocus
        unfocusBlock();
      });

      timeline.addEventListener('dblclick', (e) => {
        // Check for double-click on block name for inline editing
        const blockNameEl = e.target.closest('.block-name');
        if (blockNameEl) {
          const blockEl = blockNameEl.closest('.block');
          if (blockEl && blockEl.dataset.blockId === state.focusedBlockId) {
            activateInlineEdit(state.focusedBlockId);
            return;
          }
        }

        // Ignore double-click on existing blocks
        if (e.target.closest('.block')) {
          return;
        }

        const time = getTimeFromMouseEvent(e);
        createBlockAt(time);
      });

      // Keyboard shortcut for delete
      document.addEventListener('keydown', (e) => {
        if (state.focusedBlockId && (e.key === 'Delete' || e.key === 'Backspace')) {
          // Don't trigger if user is in an input field
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
          }
          e.preventDefault();
          deleteBlock(state.focusedBlockId);
        }
      });

      // Document-level drag handlers (both resize and move)
      document.addEventListener('mousemove', (e) => {
        if (state.moveGhost) {
          updateGhostPosition(e);
          checkAutoScroll(e);
          return; // Don't process resize while moving
        }

        if (!state.drag) return;

        const targetTime = getTimeFromMouseEvent(e);
        applyResize(state.drag.blockId, state.drag.edge, targetTime);

        // Show tooltip with the edge time
        const block = state.blocks.find(b => b.id === state.drag.blockId);
        if (block) {
          const displayTime = state.drag.edge === 'bottom' ? block.endTime : block.startTime;
          showTimeTooltip(displayTime, e);
        }

        // Auto-scroll during resize drag
        checkAutoScroll(e);

        renderBlocks();
      });

      document.addEventListener('mouseup', (e) => {
        if (state.moveGhost) {
          dropBlock();
          justFinishedDrag = true;
          setTimeout(() => justFinishedDrag = false, 0);
          return;
        }

        if (!state.drag) return;

        justFinishedDrag = true;
        setTimeout(() => justFinishedDrag = false, 0);
        state.drag = null;
        document.body.classList.remove('dragging');
        hideTimeTooltip();
        stopAutoScroll();
      });
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', initTimeline);
  </script>
</body>
</html>
